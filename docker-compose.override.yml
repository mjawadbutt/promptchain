services:
  app:
    environment:
      DEBUG_ENABLED: true
      DEBUG_PORT: 5005
      JAVA_OPTS: -Xms256m -Xmx1g
    image: ghcr.io/${GHCRIO_USERNAME}/${PROJECT_ARTIFACT_ID}:${PROJECT_VERSION}
    ports:
      - "8080:8080"
      # Remote debug port for IntelliJ
      - "5005:5005"
    # TODO: dont hardcode
    volumes:
      - ./target/logs:/app/logs
      - ./target/data:/app/data

  redis:
    ports:
      - "6379:6379"

  postgres:
    # Only needed for non-prod (non-swarm) executions.
    ports:
      - "5432:5432"

  # Creates the application's db-user (if it does not already exist).
  # Note that this is not a long-running service but just a shell script.
  # Also note that it is idempotent. So if the user already exists, then running it will not have any effect.
  db-init:
    image: postgres:15 # Use the same PostgreSQL image
    profiles:
      - db-setup # This profile will be used by your local `start-local-services.sh/.bat`
    # The command now simply executes the mounted script
    command: [ "bash", "/usr/local/bin/init-db.sh" ]
#    volumes:
#      # Mount the shared initialization script into the container
#      - ./mounted-scripts/init-db.sh:/usr/local/bin/init-db.sh:ro
    networks:
      - app-net # Connects to the same local network as your other services
    # Even though depends_on is ignored when service is executed via run.
    # Also note that "compose run" runs a one-shot short running task (as opposed to compose up)
    depends_on:
      postgres:
        condition: service_healthy

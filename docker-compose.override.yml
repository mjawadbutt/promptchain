version: "3.9"

services:
  app:
    environment:
      - DEBUG_ENABLED=true
      - DEBUG_PORT=5005
      - JAVA_OPTS=-Xms256m -Xmx1g
      # Password for app's user
      - POSTGRES_PASSWORD=myappsecret_local
    build: .
    ports:
      - "8080:8080"
      # Remote debug port for IntelliJ
      - "5005:5005"
    volumes:
      # Optional: for live code reload
      - .:/app

  redis:
    ports:
      - "6379:6379"

  postgres:
    environment:
      # Password for the default 'postgres' superuser in local development
      - POSTGRES_PASSWORD: ${POSTGRES_SUPER_PASSWORD_LOCAL}
    # Only needed for non-prod (non-swarm) executions.
    ports:
      - "5432:5432"

  # === New/Updated db-init service for Local Development ===
  db-init:
    image: postgres:15 # Use the same PostgreSQL image
    profiles:
      - db-setup # This profile will be used by your local `start-local-services.sh/.bat`
    networks:
      - app-net # Connects to the same local network as your other services
    environment:
      POSTGRES_HOST: postgres # 'postgres' is the name of your PostgreSQL service
      POSTGRES_DB: mydb
      # IMPORTANT: Use a *local* superuser password here.
      # This should be provided as an environment variable (e.g., in your shell, or a .env file for local compose)
      POSTGRES_SUPER_PASSWORD: ${POSTGRES_SUPER_PASSWORD_LOCAL}
    volumes:
      # Mount the shared initialization script into the container
      - ./mounted-scripts/init-db.sh:/usr/local/bin/init-db.sh:ro
    # Ensure Postgres is healthy before trying to run the init script
    depends_on:
      postgres:
        condition: service_healthy
    # The command now simply executes the mounted script
    command: ["bash", "/usr/local/bin/init-db.sh"]
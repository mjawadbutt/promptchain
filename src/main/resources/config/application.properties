application.name=@project.name@

# Used to create application context specific dirs such as for logging.
application.dirName=@project.name@
application.environmentId=
application.serverPort=8080
application.dataDir=target/${application.dirName}
application.tempDirPrefix=tmp

# If this is changed then uncomment the server.servlet.context-path and set it.
application.servletContextPath=/
application.sessionTimeoutInSeconds=3600

application.databaseProperties.driverClassName=org.postgresql.Driver
application.databaseProperties.username=${APP_DB_USER_NAME}
application.databaseProperties.password=${APP_DB_USER_PASSWORD}
application.databaseProperties.url=jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT:5432}/${POSTGRES_DB}

# Change this to control log level of com.promptwise.promptchain.* classes. For all others, use logging.level.*
application.loggingProperties.level=DEBUG


application.loggingProperties.rootDir=logs
application.loggingProperties.mainLogFileName=application
application.loggingProperties.mainLogFilePath=${application.loggingProperties.rootDir}/${application.loggingProperties.mainLogFileName}.log
application.loggingProperties.stacktraceLogFileName=${application.loggingProperties.mainLogFileName}.stacktrace
application.loggingProperties.stacktraceLogFilePath=${application.loggingProperties.rootDir}/${application.loggingProperties.stacktraceLogFileName}.log


application.liquibase.enabled=false

# Defaults to application.serverPort if not specified (as per SpringBoot's default behaviour) so we bind to same value in default config file.
application.actuatorPort=${application.serverPort}

application.microMeterProperties.enableJmxMetrics=true



spring.application.name=${application.name}
#Valid values: winLocal, linuxLocal (for local mac, build-server i.e. github workflow), test, and prod
spring.profiles.default=winLocal

spring.profiles.group.winLocal[0]=win
spring.profiles.group.winLocal[1]=local
#spring.profiles.group.winLocal[2]=mockXXXService

spring.profiles.group.linuxLocal[0]=linux
spring.profiles.group.linuxLocal[1]=local

server.port=${application.serverPort}

# This will be used when a normal 'kill' signal is sent by the OS.
# such as when killing the application process via 'kill' without -9
server.shutdown=graceful
server.shutdown.grace-period=60s

#server.servlet.context-path=${application.servletContextPath}
server.session-timeout=${application.sessionTimeoutInSeconds}
spring.servlet.multipart.max-file-size=50MB
spring.servlet.multipart.max-request-size=100MB
#spring.web.resources.static-locations=classpath:/static/,file:/path/to/your/static/files
spring.web.resources.static-locations=classpath:/static/client/

server.compression.enabled=true
server.mime-types=text/html,text/xml,text/plain,text/css,application/javascript,application/json

#spring.main.log-startup-info=false
# Whether the banner should be printed on System.out (console), sent to the configured logger (log), or not produced at all (off).
#spring.main.banner-mode=log



#######################################################################################################################
### Spring datasource properties:
#######################################################################################################################
spring.liquibase.enabled: ${application.liquibase.enabled}
spring.liquibase.change-log: classpath:/db/changelog/db.changelog-master.xml
spring.liquibase.contexts: localWin,localLinux,test,prod

spring.datasource.driver-class-name=${application.databaseProperties.driverClassName}
spring.datasource.url=${application.databaseProperties.url}
spring.datasource.username=${application.databaseProperties.username}
spring.datasource.password=${application.databaseProperties.password}

# Datasource connection pool properties:
spring.datasource.type=com.zaxxer.hikari.HikariDataSource
spring.datasource.hikari.connectionTimeout=30000
spring.datasource.hikari.idleTimeout=30000
spring.datasource.hikari.maxLifetime=2000000
spring.datasource.hikari.maximumPoolSize=20
spring.datasource.hikari.minimumIdle=5
spring.datasource.hikari.poolName=SpringBootJPAHikariCP

####################################################################################
### JOOQ properties:
####################################################################################

# Specifies the dialect of the actual sql-queries generated by JOOQ at runtime when a type-safe DSL operation
# is performed.
# Valid values for supported dbs are: HSQLDB,Postgres,Oracle (only in commercial/paid version)
spring.jooq.sql-dialect=POSTGRES



###############################################################################
### Logging properties:
###############################################################################

# Note:
# To ensure logging occurs in correct log files, please always specify the -Dspring.profiles.active=<profile>
# as a JVM arg eg: -Dspring.profiles.active=winLocal
# In Java 17 and above, it can ALSO be specified as a program argument instead of a VM arg.
# For example: --spring.profiles.active=<profile>

logging.charset.console=UTF-8
logging.charset.file=UTF-8
logging.level.com.promptwise.promptchain=${application.loggingProperties.level}

# Defaults is defined in logback.xml and is INFO.
logging.level.root=WARN

logging.level.liquibase=INFO
logging.level.org.springframework=WARN
logging.level.org.springframework.web=WARN
logging.level.org.hibernate=WARN
logging.level.ch.qos.logback=WARN



###############################################################################
### Spring JCache properties:
###############################################################################

spring.cache.type=jcache
spring.cache.jcache.provider=org.redisson.spring.cache.RedissonSpringCachingProvider



###############################################################################
### Spring-Actuator properties:
###############################################################################

management.server.port=${application.actuatorPort}
logging.file.name=${application.loggingProperties.mainLogFilePath}

# Disable all Actuator endpoints unless explicitly enabled (like management.endpoint.env.enabled=true)
management.endpoints.enabled-by-default=false

# Explicitly enable/disable specific endpoints:
management.endpoint.env.enabled=true
management.endpoint.env.show-values=when-authorized
management.endpoint.health.enabled=true
management.endpoint.health.show-details=when_authorized
management.endpoint.info.enabled=true
management.endpoint.logfile.enabled=true
management.endpoint.metrics.enabled=true
management.endpoint.shutdown.enabled=false

# Expose enabled endpoints over HTTP:
management.endpoints.web.exposure.include=health,info,metrics,auditevents

# Not expose enabled endpoints over HTTP:
#management.endpoints.web.exposure.exclude=


###############################################################################
### Spring MicroMeter properties:
###############################################################################

spring.jmx.enabled=${application.microMeterProperties.enableJmxMetrics}
management.metrics.enable.jvm=true
#management.metrics.enable.jvm.memory=true
#management.metrics.enable.jvm.gc=true
#management.metrics.enable.jvm.threads=true
#management.metrics.enable.jvm.classes=true
#management.metrics.enable.jvm.uptime=true

management.metrics.enable.system=true
#management.metrics.enable.system.cpu=true
#management.metrics.enable.system.filesystem=true
#management.metrics.enable.system.process=true
#management.metrics.enable.system.network=true

management.metrics.enable.http=true
management.metrics.enable.http.server.requests=true
management.metrics.enable.http.client.requests=true

# Enable Database Connection Pool Metrics (e.g., HikariCP)
management.metrics.enable.hikari=true

management.metrics.enable.datasource=true

management.metrics.enable.cache=true

management.metrics.enable.timer=true

#management.metrics.enable.spring.integration=true

# Enable Custom Metrics (enabled by default. Used to register your own metrics like counter, gauge, or timer.
# To do that you would create it, register with micro meter registry, change it as needed, and then monitor.
management.metrics.enable.custom.metrics=true

# Enable Actuator Health Metrics
management.metrics.enable.health=true

# Enable Logging Metrics
management.metrics.enable.logging=true

# Enable Thread Pool Metrics
management.metrics.enable.threadpool=true

# Enable Spring Boot Auto-Configuration Metrics
#management.metrics.enable.spring.boot.autoconfiguration=true



###############################################################################
### Miscellaneous Spring properties:
###############################################################################

# The following two properties cannot be set as below and have to remain as default because this app has endpoints
# that returns static content as well (because the angular client app is bundled) and not just JSON based
# ResponseBody objects.
#
# If we set 'spring.web.resources.add-mappings' to 'false', then the auto-configuration of the static content
# handler (ResourceHttpRequestHandler) is disabled, the client files inside classpath:/static/  (eg: index.html,
# *.js, *.css, favicon.ico, etc.) would not be served, and the NoHandlerFoundException would be propagated to our
# ControllerAdvice instead of being handled by the ResourceHttpRequestHandler.
#
# To re-enable (i.e. set it to true) this we would have to configure a customized instance of ResourceHttpRequestHandler
# so that it handles the requests for static resources just like ResourceHttpRequestHandler but in case a resource
# is not found, it customizes the behaviour to propagate the exception to ControllerAdvice rather than directly
# throwing a 404 to the client/browser. However, it would be an overkill in this case so just disabling it for now.

# Configure Spring so that it lets our ControllerAdvice handle 'NoHandlerFoundException' rather than handling
# it directly by redirecting it to Spring's DefaultHandlerExceptionResolver.
# See https://reflectoring.io/spring-boot-exception-handling/
#spring.mvc.throw-exception-if-no-handler-found=true
#spring.web.resources.add-mappings=false


# This will prevent one particular execution-flow that responds with html (which we never want) rather than JSON.
# It will occur when an AccessDeniedException is thrown anywhere and the authentication token in the
# security context represents an actual authenticated user AND NOT the 'anonymous' user (as defined by Spring).
# One case this can happen, for example, is when the CSRF token in the request was either incorrect or non-existent.
# In this case, line 174 of ExceptionTranslationFilter will be invoked which will return the response as HTML if
# an error page is configured in the AccessDeniedHandler.
# Disabling this would enable Spring to send a JSON response instead.
server.error.whitelabel.enabled=false

spring.devtools.livereload.enabled=false
spring.devtools.restart.enabled=false

application.name=@project.name@

# Used to create application-context specific dirs such as for data.
application.serverPort=8080
application.dataDir=${APP_DATA_PARENT_DIR}/${APP_DATA_DIR_NAME}
application.tempDirPrefix=tmp

# If this is changed, then uncomment the server.servlet.context-path and set it.
application.servletContextPath=/
application.sessionTimeoutInSeconds=3600

application.databaseProperties.driverClassName=org.postgresql.Driver
application.databaseProperties.username=${APP_DB_USER_NAME}
application.databaseProperties.password=${APP_DB_USER_PASSWORD}
application.databaseProperties.url=jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT:5432}/${APP_DB_NAME}?sslmode=disable
application.databaseProperties.hikariConnectionTimeout=30000
application.databaseProperties.hikariIdleTimeout=30000
application.databaseProperties.hikariMaxLifetime=2000000
application.databaseProperties.hikariMaximumPoolSize=20
application.databaseProperties.hikariMinimumIdle=5
application.databaseProperties.hikariPoolName=SpringBootJPAHikariCP

#TODO-Jawad: Make this a builder property
application.liquibase.enabled=true

# Change this to control log level of com.promptwise.promptchain.* classes. For all others, use logging.level.*
#TODO-Jawad: Make this a builder property
application.loggingProperties.level=DEBUG

application.loggingProperties.rootDir=${APP_LOGS_PARENT_DIR}/${APP_LOGS_DIR_NAME}
application.loggingProperties.mainLogFileName=application
application.loggingProperties.mainLogFilePath=${application.loggingProperties.rootDir}/${application.loggingProperties.mainLogFileName}.log
application.loggingProperties.stacktraceLogFileName=${application.loggingProperties.mainLogFileName}.stacktrace
application.loggingProperties.stacktraceLogFilePath=${application.loggingProperties.rootDir}/${application.loggingProperties.stacktraceLogFileName}.log


application.cachingProperties.redisHost=${REDIS_HOST}
application.cachingProperties.redisPort=${REDIS_PORT}
application.cachingProperties.redisPassword=${REDIS_PASSWORD}
application.cachingProperties.redisConnectionPoolSize=10
application.cachingProperties.redisConnectionMinimumIdleSize=5
application.cachingProperties.redisTimeout=10000


# Defaults to application.serverPort if not specified (as per SpringBoot's default behaviour) so we bind to same value in default config file.
application.actuatorPort=${application.serverPort}

application.microMeterProperties.enableJmxMetrics=true



spring.application.name=${application.name}

# We do not need spring profile groups. However, if we ever need to mock any bean in normal run (not junit, that is
# already supported via bean-overriding), then we can pass a --spring.profiles.active=mock and use @Profile in config.

server.port=${application.serverPort}

# This will be used when a normal 'kill' signal is sent by the OS.
# such as when killing the application process via 'kill' without -9
server.shutdown=graceful
server.shutdown.grace-period=60s

#server.servlet.context-path=${application.servletContextPath}
server.session-timeout=${application.sessionTimeoutInSeconds}
spring.servlet.multipart.max-file-size=50MB
spring.servlet.multipart.max-request-size=100MB
#spring.web.resources.static-locations=classpath:/static/,file:/path/to/your/static/files
spring.web.resources.static-locations=classpath:/static/client/

server.compression.enabled=true
server.mime-types=text/html,text/xml,text/plain,text/css,application/javascript,application/json

#spring.main.log-startup-info=false
# Whether the banner should be printed on System.out (console), sent to the configured logger (log), or not produced at all (off).
#spring.main.banner-mode=log



#######################################################################################################################
### Spring liquibase properties:
#######################################################################################################################
#TODO-Jawad: Bind these to application.liquibaseProperties and use properly
spring.liquibase.enabled: ${application.liquibase.enabled}
spring.liquibase.change-log: classpath:/db/liquibase/db.changelog-master.xml
#TODO-Jawad: Fix this later
spring.liquibase.contexts: localWin,localLinux,test,prod

# Though the liquibase datasource is set to the primary datasource by default, we intend to use a different user
# with DDL privs later.
#spring.liquibase.driver-class-name=${application.databaseProperties.driverClassName}
#spring.liquibase.url=${application.databaseProperties.url}
#spring.liquibase.user=${application.databaseProperties.username}
#spring.liquibase.password=${application.databaseProperties.password}



####################################################################################
### JOOQ properties:
####################################################################################

# Specifies the dialect of the actual sql-queries generated by JOOQ at runtime when a type-safe DSL operation
# is performed.
# Valid values for supported dbs are: HSQLDB,Postgres,Oracle (only in commercial/paid version)
spring.jooq.sql-dialect=POSTGRES



###############################################################################
### Logging properties:
###############################################################################

# Note:
# To ensure logging occurs in correct log files, please always specify the -Dspring.profiles.active=<profile>
# as a JVM arg eg: -Dspring.profiles.active=winLocal
# In Java 17 and above, it can ALSO be specified as a program argument instead of a VM arg.
# For example: --spring.profiles.active=<profile>

logging.charset.console=UTF-8
logging.charset.file=UTF-8
logging.level.com.promptwise.promptchain=${application.loggingProperties.level}

# Defaults is defined in logback.xml and is INFO.
logging.level.root=WARN

logging.level.liquibase=INFO
logging.level.org.springframework=WARN
logging.level.org.springframework.web=WARN
logging.level.org.springframework.boot.autoconfigure=WARN
logging.level.org.hibernate=WARN
logging.level.ch.qos.logback=WARN



###############################################################################
### Spring JCache properties:
###############################################################################

# These need not be configured since we are doing programmatic config
spring.cache.type=jcache
spring.cache.jcache.provider=org.redisson.jcache.JCachingProvider
#spring.cache.jcache.config=classpath:redisson-jcache.yaml


###############################################################################
### Redisson properties:
###############################################################################
#spring.data.redis.client=redisson
#debug=true
# --- Redisson Specific Configuration ---
#spring.redisson.single-server-config.address=redis://${REDIS_HOST}:${REDIS_PORT:6379}
#spring.redisson.single-server-config.password=${REDIS_PASSWORD}
#spring.redisson.single-server-config.connection-pool-size=10
#spring.redisson.single-server-config.connection-minimum-idle-size=2
#spring.redisson.single-server-config.idle-connection-timeout=10000
#spring.redisson.single-server-config.connect-timeout=10000
#spring.redisson.single-server-config.timeout=3000
#spring.redisson.single-server-config.retry-attempts=3
#spring.redisson.single-server-config.retry-interval=1500
#spring.redisson.threads=4
#spring.redisson.netty-threads=4



###############################################################################
### Spring-Actuator properties:
###############################################################################

management.server.port=${application.actuatorPort}
logging.file.name=${application.loggingProperties.mainLogFilePath}

# Disable all Actuator endpoints unless explicitly enabled (like management.endpoint.env.enabled=true)
management.endpoints.enabled-by-default=false

# Explicitly enable/disable specific endpoints:
management.endpoint.env.enabled=true
management.endpoint.env.show-values=when-authorized
management.endpoint.health.enabled=true
management.endpoint.health.show-details=when_authorized
management.endpoint.info.enabled=true
management.endpoint.logfile.enabled=true
management.endpoint.metrics.enabled=true
management.endpoint.shutdown.enabled=false

# Expose enabled endpoints over HTTP:
management.endpoints.web.exposure.include=health,info,metrics,auditevents

# Not expose enabled endpoints over HTTP:
#management.endpoints.web.exposure.exclude=


###############################################################################
### Spring MicroMeter properties:
###############################################################################

spring.jmx.enabled=${application.microMeterProperties.enableJmxMetrics}
management.metrics.enable.jvm=true
#management.metrics.enable.jvm.memory=true
#management.metrics.enable.jvm.gc=true
#management.metrics.enable.jvm.threads=true
#management.metrics.enable.jvm.classes=true
#management.metrics.enable.jvm.uptime=true

management.metrics.enable.system=true
#management.metrics.enable.system.cpu=true
#management.metrics.enable.system.filesystem=true
#management.metrics.enable.system.process=true
#management.metrics.enable.system.network=true

management.metrics.enable.http=true
management.metrics.enable.http.server.requests=true
management.metrics.enable.http.client.requests=true

# Enable Database Connection Pool Metrics (e.g., HikariCP)
management.metrics.enable.hikari=true

management.metrics.enable.datasource=true

management.metrics.enable.cache=true

management.metrics.enable.timer=true

#management.metrics.enable.spring.integration=true

# Enable Custom Metrics (enabled by default. Used to register your own metrics like counter, gauge, or timer.
# To do that you would create it, register with micro meter registry, change it as needed, and then monitor.
management.metrics.enable.custom.metrics=true

# Enable Actuator Health Metrics
management.metrics.enable.health=true

# Enable Logging Metrics
management.metrics.enable.logging=true

# Enable Thread Pool Metrics
management.metrics.enable.threadpool=true

# Enable Spring Boot Auto-Configuration Metrics
#management.metrics.enable.spring.boot.autoconfiguration=true



###############################################################################
### Miscellaneous Spring properties:
###############################################################################

# The following two properties cannot be set as below and have to remain as default because this app has endpoints
# that returns static content as well (because the angular client app is bundled) and not just JSON based
# ResponseBody objects.
#
# If we set 'spring.web.resources.add-mappings' to 'false', then the auto-configuration of the static content
# handler (ResourceHttpRequestHandler) is disabled, the client files inside classpath:/static/  (eg: index.html,
# *.js, *.css, favicon.ico, etc.) would not be served, and the NoHandlerFoundException would be propagated to our
# ControllerAdvice instead of being handled by the ResourceHttpRequestHandler.
#
# To re-enable (i.e. set it to true) this we would have to configure a customized instance of ResourceHttpRequestHandler
# so that it handles the requests for static resources just like ResourceHttpRequestHandler but in case a resource
# is not found, it customizes the behaviour to propagate the exception to ControllerAdvice rather than directly
# throwing a 404 to the client/browser. However, it would be an overkill in this case so just disabling it for now.

# Configure Spring so that it lets our ControllerAdvice handle 'NoHandlerFoundException' rather than handling
# it directly by redirecting it to Spring's DefaultHandlerExceptionResolver.
# See https://reflectoring.io/spring-boot-exception-handling/
#spring.mvc.throw-exception-if-no-handler-found=true
#spring.web.resources.add-mappings=false


# This will prevent one particular execution-flow that responds with html (which we never want) rather than JSON.
# It will occur when an AccessDeniedException is thrown anywhere and the authentication token in the
# security context represents an actual authenticated user AND NOT the 'anonymous' user (as defined by Spring).
# One case this can happen, for example, is when the CSRF token in the request was either incorrect or non-existent.
# In this case, line 174 of ExceptionTranslationFilter will be invoked which will return the response as HTML if
# an error page is configured in the AccessDeniedHandler.
# Disabling this would enable Spring to send a JSON response instead.
server.error.whitelabel.enabled=false

spring.devtools.livereload.enabled=false
spring.devtools.restart.enabled=false
